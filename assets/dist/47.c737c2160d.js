"use strict";(self.webpackChunkvwww=self.webpackChunkvwww||[]).push([["47"],{55:function(e,t,n){n.d(t,{q:()=>w});var a=n(4),r=n(8),o=n(13),s=n(38),l=n(37),i=n(14),c=n(39),d=n(11),h=n(22),v=n(12),u=n(6),f=n(9);function w(e,t,n=!1,_=!1,m=!1){var p=e,y="";(0,r.vN)(()=>{var e=u.Fg;if(y===(y=t()??"")){o.fE&&(0,o.E$)();return}if(null!==e.nodes_start&&((0,r.mk)(e.nodes_start,e.nodes_end),e.nodes_start=e.nodes_end=null),""!==y){if(o.fE){for(var w=o.Xb.data,b=(0,o.E$)(),g=b;null!==b&&(b.nodeType!==f.dz||""!==b.data);)g=b,b=(0,v.M$)(b);if(null===b)throw i.eZ(),a.kD;d.A&&!m&&function(e,t,n){let r;if(!t||t===(0,c.tW)(String(n??"")))return;let o=e.__svelte_meta?.loc;o?r=`near ${o.file}:${o.line}:${o.column}`:h.DE?.[a.Uh]&&(r=`in ${h.DE[a.Uh]}`),i.Y9((0,c.If)(r))}(b.parentNode,w,y),(0,l.mX)(o.Xb,g),p=(0,o.W0)(b);return}var $=y+"";n?$=`<svg>${$}</svg>`:_&&($=`<math>${$}</math>`);var T=(0,s.L)($);if((n||_)&&(T=(0,v.Zj)(T)),(0,l.mX)((0,v.Zj)(T),T.lastChild),n||_)for(;(0,v.Zj)(T);)p.before((0,v.Zj)(T));else p.before(T)}})}},66:function(e,t,n){n(8),n(31),n(16),n(7)},14:function(e,t,n){n.d(t,{Cy:()=>l,Y9:()=>c,YY:()=>h,_2:()=>s,eZ:()=>d,ns:()=>v,zn:()=>i});var a=n(11),r="font-weight: bold",o="font-weight: normal";function s(e){a.A?console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${e}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`,r,o):console.warn("https://svelte.dev/e/await_reactivity_loss")}function l(e,t){a.A?console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${e}\` (${t}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`,r,o):console.warn("https://svelte.dev/e/await_waterfall")}function i(e,t,n){a.A?console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${e}\` attribute on \`${t}\` changed its value between server and client renders. The client value, \`${n}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`,r,o):console.warn("https://svelte.dev/e/hydration_attribute_changed")}function c(e){a.A?console.warn(`%c[svelte] hydration_html_changed
%c${e?`The value of an \`{@html ...}\` block ${e} changed between server and client renders. The client value will be ignored in favour of the server value`:"The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,r,o):console.warn("https://svelte.dev/e/hydration_html_changed")}function d(e){a.A?console.warn(`%c[svelte] hydration_mismatch
%c${e?`Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${e}`:"Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,r,o):console.warn("https://svelte.dev/e/hydration_mismatch")}function h(){a.A?console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`,r,o):console.warn("https://svelte.dev/e/lifecycle_double_unmount")}function v(e){a.A?console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${e}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`,r,o):console.warn("https://svelte.dev/e/state_proxy_equality_mismatch")}},39:function(e,t,n){n.d(t,{GY:()=>s,If:()=>l,tW:()=>r});let a=/\r/g;function r(e){e=e.replace(a,"");let t=5381,n=e.length;for(;n--;)t=(t<<5)-t^e.charCodeAt(n);return(t>>>0).toString(36)}let o=["touchstart","touchmove"];function s(e){return o.includes(e)}function l(e){return e?.replace(/\//g,"/â€‹")}}}]);